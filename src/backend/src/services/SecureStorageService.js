const crypto = require('../utils/crypto');
const logger = require('../utils/logger');\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n/**\n * 安全存储服务\n * 负责敏感信息的安全存储和管理\n */\nclass SecureStorageService {\n  constructor() {\n    this.storageDir = path.join(os.homedir(), '.temctl', 'secure');\n    this.initStorage();\n  }\n\n  /**\n   * 初始化存储目录\n   */\n  initStorage() {\n    try {\n      if (!fs.existsSync(this.storageDir)) {\n        fs.mkdirSync(this.storageDir, { recursive: true, mode: 0o700 });\n      }\n      logger.database('安全存储目录已初始化');\n    } catch (error) {\n      logger.error('初始化安全存储目录失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 存储SSH密钥\n   */\n  async storeSSHKey(keyId, keyData, keyType = 'private') {\n    try {\n      const fileName = `ssh_${keyId}_${keyType}.key`;\n      const filePath = path.join(this.storageDir, fileName);\n      \n      // 加密密钥数据\n      const encryptedKey = await crypto.encrypt(keyData);\n      \n      // 写入文件\n      fs.writeFileSync(filePath, encryptedKey, { mode: 0o600 });\n      \n      logger.database('SSH密钥已安全存储', { keyId, keyType });\n      \n      return {\n        keyId,\n        keyType,\n        filePath: fileName, // 只返回文件名，不暴露完整路径\n        stored: true\n      };\n    } catch (error) {\n      logger.error('存储SSH密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 读取SSH密钥\n   */\n  async retrieveSSHKey(keyId, keyType = 'private') {\n    try {\n      const fileName = `ssh_${keyId}_${keyType}.key`;\n      const filePath = path.join(this.storageDir, fileName);\n      \n      if (!fs.existsSync(filePath)) {\n        throw new Error('SSH密钥文件不存在');\n      }\n      \n      // 读取加密数据\n      const encryptedKey = fs.readFileSync(filePath, 'utf8');\n      \n      // 解密密钥数据\n      const keyData = await crypto.decrypt(encryptedKey);\n      \n      logger.database('SSH密钥已读取', { keyId, keyType });\n      \n      return keyData;\n    } catch (error) {\n      logger.error('读取SSH密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 删除SSH密钥\n   */\n  async deleteSSHKey(keyId, keyType = 'private') {\n    try {\n      const fileName = `ssh_${keyId}_${keyType}.key`;\n      const filePath = path.join(this.storageDir, fileName);\n      \n      if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n        logger.database('SSH密钥已删除', { keyId, keyType });\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      logger.error('删除SSH密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 存储主机密码\n   */\n  async storeHostPassword(hostId, password) {\n    try {\n      // 使用主机ID作为额外的安全层\n      const encryptedPassword = await crypto.encryptPassword(password);\n      \n      logger.database('主机密码已加密存储', { hostId });\n      \n      return encryptedPassword;\n    } catch (error) {\n      logger.error('存储主机密码失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 读取主机密码\n   */\n  async retrieveHostPassword(hostId, encryptedPassword) {\n    try {\n      const password = await crypto.decryptPassword(encryptedPassword);\n      \n      logger.database('主机密码已解密', { hostId });\n      \n      return password;\n    } catch (error) {\n      logger.error('读取主机密码失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成SSH密钥对\n   */\n  async generateSSHKeyPair(keyId, keySize = 2048, passphrase = null) {\n    try {\n      const keyPair = crypto.generateKeyPair(keySize);\n      \n      // 如果提供了密码短语，加密私钥\n      let privateKey = keyPair.privateKey;\n      if (passphrase) {\n        privateKey = await crypto.encrypt(privateKey, passphrase);\n      }\n      \n      // 存储密钥对\n      const privateKeyInfo = await this.storeSSHKey(keyId, privateKey, 'private');\n      const publicKeyInfo = await this.storeSSHKey(keyId, keyPair.publicKey, 'public');\n      \n      logger.database('SSH密钥对已生成并存储', { keyId, keySize });\n      \n      return {\n        keyId,\n        privateKey: privateKeyInfo,\n        publicKey: publicKeyInfo,\n        fingerprint: crypto.hash(keyPair.publicKey),\n        keySize,\n        hasPassphrase: !!passphrase\n      };\n    } catch (error) {\n      logger.error('生成SSH密钥对失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 导入SSH密钥\n   */\n  async importSSHKey(keyId, keyData, keyType = 'private', passphrase = null) {\n    try {\n      // 验证密钥格式\n      this.validateSSHKey(keyData, keyType);\n      \n      // 如果是私钥且提供了密码短语，先解密再重新加密\n      let processedKey = keyData;\n      if (keyType === 'private' && passphrase) {\n        // TODO: 实现私钥密码短语处理\n        processedKey = keyData;\n      }\n      \n      // 存储密钥\n      const keyInfo = await this.storeSSHKey(keyId, processedKey, keyType);\n      \n      logger.database('SSH密钥已导入', { keyId, keyType });\n      \n      return {\n        ...keyInfo,\n        fingerprint: crypto.hash(keyData)\n      };\n    } catch (error) {\n      logger.error('导入SSH密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 导出SSH密钥\n   */\n  async exportSSHKey(keyId, keyType = 'public') {\n    try {\n      const keyData = await this.retrieveSSHKey(keyId, keyType);\n      \n      logger.database('SSH密钥已导出', { keyId, keyType });\n      \n      return keyData;\n    } catch (error) {\n      logger.error('导出SSH密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 验证SSH密钥格式\n   */\n  validateSSHKey(keyData, keyType) {\n    try {\n      if (keyType === 'public') {\n        // 验证公钥格式\n        if (!keyData.includes('ssh-') && !keyData.includes('BEGIN')) {\n          throw new Error('无效的公钥格式');\n        }\n      } else if (keyType === 'private') {\n        // 验证私钥格式\n        if (!keyData.includes('BEGIN') || !keyData.includes('PRIVATE KEY')) {\n          throw new Error('无效的私钥格式');\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      logger.error('SSH密钥格式验证失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 列出存储的密钥\n   */\n  async listStoredKeys() {\n    try {\n      const files = fs.readdirSync(this.storageDir);\n      const keys = [];\n      \n      files.forEach(file => {\n        const match = file.match(/^ssh_(.+)_(private|public)\\.key$/);\n        if (match) {\n          const [, keyId, keyType] = match;\n          let existingKey = keys.find(k => k.keyId === keyId);\n          \n          if (!existingKey) {\n            existingKey = {\n              keyId,\n              types: [],\n              createdAt: fs.statSync(path.join(this.storageDir, file)).birthtime\n            };\n            keys.push(existingKey);\n          }\n          \n          existingKey.types.push(keyType);\n        }\n      });\n      \n      return keys;\n    } catch (error) {\n      logger.error('列出存储密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 清理过期或无效的密钥\n   */\n  async cleanupKeys() {\n    try {\n      const files = fs.readdirSync(this.storageDir);\n      let cleanedCount = 0;\n      \n      for (const file of files) {\n        const filePath = path.join(this.storageDir, file);\n        const stats = fs.statSync(filePath);\n        \n        // 清理超过1年未使用的密钥文件\n        const oneYearAgo = new Date();\n        oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n        \n        if (stats.atime < oneYearAgo) {\n          fs.unlinkSync(filePath);\n          cleanedCount++;\n          logger.database('清理过期密钥文件', { file });\n        }\n      }\n      \n      return { cleanedCount };\n    } catch (error) {\n      logger.error('清理密钥失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 备份安全存储\n   */\n  async backupSecureStorage(backupPath) {\n    try {\n      const archiver = require('archiver');\n      const archive = archiver('zip', { zlib: { level: 9 } });\n      \n      const output = fs.createWriteStream(backupPath);\n      archive.pipe(output);\n      \n      // 添加存储目录到备份\n      archive.directory(this.storageDir, 'secure-storage');\n      \n      await archive.finalize();\n      \n      logger.database('安全存储已备份', { backupPath });\n      \n      return { success: true, backupPath };\n    } catch (error) {\n      logger.error('备份安全存储失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 恢复安全存储\n   */\n  async restoreSecureStorage(backupPath) {\n    try {\n      const AdmZip = require('adm-zip');\n      const zip = new AdmZip(backupPath);\n      \n      // 清空现有存储目录\n      if (fs.existsSync(this.storageDir)) {\n        fs.rmSync(this.storageDir, { recursive: true });\n      }\n      \n      // 解压备份\n      zip.extractAllTo(path.dirname(this.storageDir), true);\n      \n      logger.database('安全存储已恢复', { backupPath });\n      \n      return { success: true };\n    } catch (error) {\n      logger.error('恢复安全存储失败:', error);\n      throw error;\n    }\n  }\n}\n\n// 创建全局安全存储服务实例\nconst secureStorage = new SecureStorageService();\n\nmodule.exports = secureStorage;